/**
 * Open-Ended Experiment 2
 *
 * A road network can be considered as a graph with positive weights. The nodes
 * represent road junctions and each edge of the graph is associated with a road
 * segment between two junctions. The weight of an edge may correspond to the
 * length of the associated road segment, the time needed to traverse the
 * segment or the cose of traversing the segment. Using directed edges it is
 * also possible to model one-way streets. Such graphs are special in the sense
 * that some edges are more important than others for long distance travel (e.g.
 * highways). This property has been formalized using the notion of highway
 * dimension. There are a great number of algorithms that exploit this property
 * and are therefore able to compute the shortest path a lot quicker than would
 * be possible on general graphs. Develop a program to find the shortest path
 * from each node to solve the road network problem.
 * 
 * The Floyd-Warshall algorithm is used to solve said problem.
 * This file generates the parent and distance matrices and passes them along to
 * the python file.
 */

// Included Libraries
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Macro definitions
#define INT_TO_CHAR(A) (A + 48)

/** @brief Whether weight is infinity or not */
enum Status {
    VALUE    = 0,
    INFINITY = 1
};

/** @brief Structure containing status and weight of each edge */
struct Weight {
    enum Status status;  // Whether weight is infinity or not
    int         weight;  // Weight of edge
};

/**
 * @brief Prints weight matrix generated by algorithm
 * @param matrix Matrix containing weights
 * @param len Length of matrix
 */
void          print_weight_matrix(struct Weight** matrix, int len);
/**
 * @brief Prints parent matrix generated by Floyd-Warshall algorithm
 * @param matrix Matrix containing element parents
 * @param len Length of matrix
 */
void          print_parent_matrix(char** matrix, int len);
/**
 * @brief Adds two weights and return sum `Weight` object
 * @param e1 First element in addition
 * @param e2 Second element in addition
 * @return Weight wise sum of @p e1 and @p e2
 */
struct Weight add_element(struct Weight e1, struct Weight e2);
/**
 * @brief Returns minimum of two weights
 * @param e1 First element in comparison
 * @param e2 Second element in comparison
 * @return Smaller element of @p e1 and @p e2
 */
struct Weight min_element(struct Weight e1, struct Weight e2);
/**
 * @brief Executes the Floyd-Warshall algorithm on the given @p adj adjacency
 * matrix and prints the final weight and parent matrices
 * @param adj Adjacency matrix of graph
 * @param len Length of matrix
 */
void          floyd_warshall(struct Weight** adj, int len);

int
main(int argc, char** argv) {
    int            node_count   = 5; // Number of nodes
    struct Weight* adj[] = {         // Adjacency Matrix of graph
        (struct Weight[]) {   { .status = VALUE, .weight = 0 },
                           { .status = VALUE, .weight = 3 },
                           { .status = VALUE, .weight = 8 },
                           { .status = INFINITY, .weight = 0 },
                           { .status = VALUE, .weight = -4 }  },
        (struct Weight[]) {{ .status = INFINITY, .weight = 0 },
                           { .status = VALUE, .weight = 0 },
                           { .status = INFINITY, .weight = 0 },
                           { .status = VALUE, .weight = 1 },
                           { .status = VALUE, .weight = 7 }   },
        (struct Weight[]) {{ .status = INFINITY, .weight = 0 },
                           { .status = VALUE, .weight = 4 },
                           { .status = VALUE, .weight = 0 },
                           { .status = INFINITY, .weight = 0 },
                           { .status = INFINITY, .weight = 0 }},
        (struct Weight[]) {   { .status = VALUE, .weight = 2 },
                           { .status = INFINITY, .weight = 0 },
                           { .status = VALUE, .weight = -5 },
                           { .status = VALUE, .weight = 0 },
                           { .status = INFINITY, .weight = 0 }},
        (struct Weight[]) {{ .status = INFINITY, .weight = 0 },
                           { .status = INFINITY, .weight = 0 },
                           { .status = INFINITY, .weight = 0 },
                           { .status = VALUE, .weight = 6 },
                           { .status = VALUE, .weight = 0 }   }
    };

    // int len = 6;
    // struct Weight* adj[] = {
    //     (struct Weight[]) {   { .status = VALUE, .weight = 0 },
    //                        { .status = VALUE, .weight = 1 },
    //                        { .status = VALUE, .weight = 5 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 }},
    //     (struct Weight[]) {{ .status = INFINITY, .weight = 0 },
    //                        { .status = VALUE, .weight = 0 },
    //                        { .status = VALUE, .weight = 2 },
    //                        { .status = VALUE, .weight = 2 },
    //                        { .status = VALUE, .weight = 1 },
    //                        { .status = INFINITY, .weight = 0 }},
    //     (struct Weight[]) {{ .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = VALUE, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = VALUE, .weight = 2 },
    //                        { .status = INFINITY, .weight = 0 }},
    //     (struct Weight[]) {{ .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = VALUE, .weight = 0 },
    //                        { .status = VALUE, .weight = 3 },
    //                        { .status = VALUE, .weight = 1 }   },
    //     (struct Weight[]) {{ .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = VALUE, .weight = 0 },
    //                        { .status = VALUE, .weight = 2 }   },
    //     (struct Weight[]) {{ .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = INFINITY, .weight = 0 },
    //                        { .status = VALUE, .weight = 0 }   }
    // };

    fprintf(stdout, "%d\n", node_count);
    print_weight_matrix(adj, node_count);
    floyd_warshall(adj, node_count);

    return 0;
}

void
print_weight_matrix(struct Weight** matrix, int len) {
    for ( int i = 0; i < len; i++ ) {
        for ( int j = 0; j < len; j++ ) {
            if ( matrix[i][j].status == INFINITY ) {
                fprintf(stdout, "  %c", 'I');
            } else {
                fprintf(stdout, "%3d", matrix[i][j].weight);
            }
        }

        fprintf(stdout, "\n");
    }
}

void
print_parent_matrix(char** matrix, int len) {
    for ( int i = 0; i < len; i++ ) {
        for ( int j = 0; j < len; j++ ) {
            fprintf(stdout, "%3c", matrix[i][j]);
        }

        fprintf(stdout, "\n");
    }
}

struct Weight
add_element(struct Weight w1, struct Weight w2) {
    if ( w1.status == INFINITY ) {
        return w1;
    } else if ( w2.status == INFINITY ) {
        return w2;
    } else {
        return (struct Weight) { .status = VALUE,
                                 .weight = w1.weight + w2.weight };
    }
}

struct Weight
min_element(struct Weight w1, struct Weight w2) {
    if ( w2.status == INFINITY ) {
        return w1;
    } else if ( w1.status == INFINITY ) {
        return w2;
    } else {
        return (w1.weight <= w2.weight) ? w1 : w2;
    }
}

void
floyd_warshall(struct Weight** adj, int len) {
    // Allocate and define distance and parent matrices
    struct Weight** D =
        ( struct Weight** ) malloc(len * sizeof(struct Weight*));
    struct Weight** D_new =
        ( struct Weight** ) malloc(len * sizeof(struct Weight*));
    char** parent     = ( char** ) malloc(len * sizeof(char*));
    char** parent_new = ( char** ) malloc(len * sizeof(char*));

    for ( int i = 0; i < len; i++ ) {
        D[i]          = ( struct Weight* ) malloc(len * sizeof(struct Weight));
        D_new[i]      = ( struct Weight* ) malloc(len * sizeof(struct Weight));
        parent[i]     = ( char* ) malloc(len * sizeof(char));
        parent_new[i] = ( char* ) malloc(len * sizeof(char));

        for ( int j = 0; j < len; j++ ) {
            D_new[i][j].status = VALUE;
            D_new[i][j].weight = 0;
        }
    }

    // Populate distance matrix
    for ( int i = 0; i < len; i++ ) {
        memcpy(D[i], adj[i], len * sizeof(struct Weight));
    }

    // Populate parent matrix
    for ( int i = 0; i < len; i++ ) {
        for ( int j = 0; j < len; j++ ) {
            if ( i == j ) {
                parent[i][j] = 'N';
            } else if ( D[i][j].status == INFINITY ) {
                parent[i][j] = 'N';
            } else {
                parent[i][j] = INT_TO_CHAR(i + 1);
            }
        }
    }

    // Running FLoyd-Warshall algorithm to create next successive generations
    // of distance and parent matrices
    for ( int k = 0; k < len; k++ ) {
        for ( int i = 0; i < len; i++ ) {
            for ( int j = 0; j < len; j++ ) {
                struct Weight temp = add_element(D[i][k], D[k][j]);

                D_new[i][j] = min_element(D[i][j], temp);

                if ( D[i][j].status == INFINITY ) {
                    parent_new[i][j] = parent[k][j];
                } else if ( temp.status == INFINITY ) {
                    parent_new[i][j] = parent[i][j];
                } else {
                    if ( D[i][j].weight > temp.weight ) {
                        parent_new[i][j] = parent[k][j];
                    } else {
                        parent_new[i][j] = parent[i][j];
                    }
                }
            }
        }

        for ( int i = 0; i < len; i++ ) {
            memcpy(D[i], D_new[i], len * sizeof(struct Weight));
            memcpy(parent[i], parent_new[i], len * sizeof(char));
        }
    }

    // Print distance and parent matrices to STDIN to be read by python file
    print_weight_matrix(D, len);
    print_parent_matrix(parent, len);

    // Deallocate distance and parent matrices
    for ( int i = 0; i < len; i++ ) {
        free(D[i]);
        free(D_new[i]);
        free(parent[i]);
        free(parent_new[i]);
    }

    free(D);
    free(D_new);
    free(parent);
    free(parent_new);
}